# Студенты против Злоключений


Проект в жанре Tower Defense, разработанный на Python с использованием библиотеки Pygame. Игроку предстоит защищать свою зачетку от волн "злоключений" — врагов, олицетворяющих трудности студенческой жизни.

## Оглавление
- [Обзор Игры](#обзор-игры)
- [Ключевые Особенности](#ключевые-особенности)
- [Установка и Запуск](#установка-и-запуск)
- [Структура Проекта](#структура-проекта)
- [Архитектура Кода](#архитектура-кода)
- [Разбор Алгоритмов](#разбор-алгоритмов)
- [Кастомизация и Добавление Контента](#кастомизация-и-добавление-контента)

---

## Обзор Игры

**«Студенты против Злоключений»** — это классический Tower Defense с уникальным сеттингом.

Игровой процесс делится на две ключевые фазы:

1.  **Фаза Подготовки:** Перед боем игрок использует "стипендию" для формирования команды студентов-защитников. На этом этапе можно улучшать их характеристики: урон, скорость атаки, радиус и т.д.
2.  **Фаза Боя:** Игрок расставляет выбранных студентов на игровом поле, используя ресурс "кофе". Студенты автоматически атакуют врагов, а игрок должен грамотно распоряжаться ресурсами и тактически верно расставлять юнитов, чтобы отбить все волны.

---

## Ключевые Особенности

*   **Уникальные юниты:** 8 разных типов студентов-защитников с уникальными механиками (стрелки, АОЕ-атаки, юниты поддержки, камикадзе, генераторы ресурсов).
*   **Разнообразные враги:** 5 типов врагов со своим поведением (обычные, дальнобойные, прыгающие, охотники за сильными юнитами, охотники за ресурсами).
*   **Система улучшений:** Возможность улучшать урон, скорость атаки и другие параметры героев между уровнями.
*   **"Напасти" (Calamities):** Случайные события, которые происходят во время боя и могут кардинально изменить ход игры, ослабляя героев или усиливая врагов.
*   **Нейросети:** Одноразовые "газонокосилки", служащие последним рубежом обороны на каждой линии.
*   **Прогрессия:** 5 уровней с нарастающей сложностью и постепенным введением новых врагов и механик.
*   **Тестовый режим:** Отдельный уровень-песочница для тестирования всех юнитов и механик.
*   **Проработанный UI:** Стильный и интуитивно понятный интерфейс, включая кастомные фоны, кнопки и панели.

---

## Установка и Запуск

#### Требования
*   **Python** 3.8+
*   Библиотека **Pygame**

#### Установка и запуск

1.  Клонируйте репозиторий или скачайте архив с кодом.
2.  Установите библиотеку Pygame через терминал или командную строку:
    ```bash
    pip install pygame
    ```
3.  Перейдите в корневую папку проекта и запустите игру:
    ```bash
    python main.py
    ```

---

## Структура Проекта

Проект имеет четкую модульную структуру, что упрощает навигацию, поддержку и расширение.

```
/
├── core/                   # Ядро игры, менеджеры и основная логика
│   ├── game_manager.py     # Главный класс игры, управляет состояниями
│   ├── prep_manager.py     # Логика экрана подготовки
│   ├── battle_manager.py   # Логика боя
│   ├── level_manager.py    # Управляет волнами врагов
│   ├── pathfinding.py      # Алгоритм поиска пути A*
│   └── sound_manager.py    # Управляет звуком и музыкой
│
├── data/                   # Данные и настройки
│   ├── configs/            # Папка с разделенными файлами настроек
│   │   ├── defenders.py    # Данные защитников
│   │   ├── enemies.py      # Данные врагов
│   │   └── ...             # (и другие конфиги)
│   ├── assets.py           # Загрузка всех ассетов
│   ├── levels.py           # Конфигурация всех уровней
│   └── settings.py         # Файл-агрегатор для всех настроек
│
├── entities/               # Игровые объекты (спрайты)
│   ├── defenders.py        # Классы студентов-защитников
│   ├── enemies.py          # Классы врагов
│   ├── projectiles.py      # Классы снарядов
│   ├── other_sprites.py    # Кофе, ауры, нейросети
│   └── base_sprite.py      # Базовый класс для всех спрайтов
│
├── ui/                     # Модули отрисовки интерфейса
│   ├── base_component.py   # Базовый класс для UI с общими методами
│   ├── battle_hud_renderer.py # Отрисовка магазина и HUD в бою
│   ├── ..._renderer.py     # Специализированные рендереры для каждого экрана
│   └── ui_manager.py       # Фасад, управляющий всеми рендерерами
│
├── assets/                 # Графика и звук
│   ├── images/
│   └── sounds/
│
└── main.py                 # Точка входа в приложение
```

---

## Архитектура Кода

Архитектура проекта построена на нескольких ключевых паттернах и принципах.

#### Принцип разделения ответственности (SRP)
Каждый компонент системы имеет одну, четко определенную зону ответственности:
*   **`GameManager`**: Управляет общим состоянием игры (меню, бой и т.д.) и переключает их.
*   **`BattleManager`**: Управляет исключительно логикой боя.
*   **`PrepManager`**: Управляет логикой экрана подготовки.
*   **`UIManager`**: Выступает в роли **Фасада**, делегируя отрисовку конкретных экранов специализированным рендерерам.

#### Data-Driven Design (Управление через данные)
Вместо жесткого кодирования характеристик юнитов в их классах, все эти данные вынесены в файлы в `data/configs/`. Классы (`ProgrammerBoy`, `Calculus`) читают эти данные при инициализации. Это позволяет легко менять баланс и добавлять новый контент, не трогая код.

#### Иерархия наследования (OOP)
Все игровые объекты наследуются от общего базового класса, что позволяет избежать дублирования кода (принцип DRY).
*   `pygame.sprite.Sprite`
    *   `BaseSprite` (наш базовый класс)
        *   `Defender` / `Enemy` (общая логика для всех защитников/врагов)
            *   `ProgrammerBoy` / `Calculus` (конкретные реализации с уникальным поведением)

#### Конечный автомат (State Machine)
`GameManager` реализует этот паттерн с помощью словаря-диспетчера. Вместо громоздкого `if/elif` он элегантно вызывает нужный метод-обработчик для текущего состояния (`'MAIN_MENU'`, `'PLAYING'`, `'PAUSED'` и т.д.), что делает код чище и проще для понимания.

---

## Разбор Алгоритмов

1.  **Поиск пути A***: Наиболее сложный алгоритм в проекте. Реализован в `core/pathfinding.py` и используется врагом "Наркоман" (`Addict`), чтобы найти оптимальный путь к своей цели, обходя препятствия (других защитников). Алгоритм использует приоритетную очередь (`heapq`) для эффективного выбора узлов.

2.  **Параболическая траектория прыжка**: Враг "Злая математичка" (`MathTeacher`) для перепрыгивания препятствий использует нелинейную интерполяцию. Ее движение по вертикали описывается синусоидальной функцией (`math.sin`), что в сумме с линейным горизонтальным движением создает плавную параболическую дугу.

3.  **Управление темпом игры**: `LevelManager` использует динамический интервал для появления врагов. При достижении порога `FINAL_WAVE_THRESHOLD`, задержка между появлением врагов значительно сокращается, создавая напряженную "финальную волну".

4.  **Применение эффектов по области (AOE)**: Юниты `BotanistGirl` (взрыв) и `Activist` (аура) используют проверки на расстояние или столкновения в радиусе для применения своих эффектов к нескольким целям одновременно.

---

## Кастомизация и Добавление Контента

Благодаря Data-Driven архитектуре, добавлять новый контент в игру очень просто.

#### Как добавить нового героя:
1.  **Ассеты:** Нарисуйте анимации (`idle_0.png`, `attack_0.png` и т.д.) и поместите их в новую папку, например, `assets/images/defenders/new_hero/`.
2.  **Данные:** Откройте `data/configs/defenders.py` и добавьте новый словарь с ключом `'new_hero'`. Опишите все его характеристики (`cost`, `health`, `damage`, `description`, `animation_data` и т.д.).
3.  **Класс:** В `entities/defenders.py` создайте новый класс `NewHero`, унаследовав его от `Defender`. Если у него есть уникальная механика, переопределите метод `update`.
4.  **Регистрация:** В `core/battle_manager.py` в методе `_place_defender` добавьте `'new_hero': NewHero` в словарь `unit_map`.

#### Как добавить новый уровень:
1.  Откройте `data/levels.py`.
2.  Скопируйте существующий словарь уровня и вставьте его с новым ID (например, `6`).
3.  Измените `name`, `start_coffee` и список `enemies`, задав последовательность появления врагов.
4.  Игра автоматически подхватит новый уровень и отобразит его в главном меню, как только предыдущий будет пройден.
